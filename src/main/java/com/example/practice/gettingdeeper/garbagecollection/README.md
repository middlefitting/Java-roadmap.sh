## 개요
가비지 수집은 아주 메모리 관리 자동화 프로세스입니다. JVM 스펙만 만족한다는 전제하에 모든 JVM 구현체에서 구현이 가능합니다.

오라클 HotSpot JVM이 유명하기 때문에 이를 기반으로 작성합니다.

## Garbage Collection Steps
- 첫째로, 레퍼런스되어 있지 않은 객체들을 식별하고 마킹합니다.
- 둘째로, 마킹된 오브젝트들을 제거합니다(메모리 해제).
- 셋째로, 선택적으로 남아있는 불연속적인 메모리 객체들을 메모리의 시작 부분으로 모으는 메모리 압축을 진행합니다. 이는 JVM이 빈 공간을 쉽게 찾아서 연속적으로 할당할 수 있게 합니다.

## HotSpot's Generational Garbage Collection Strategy
핫스팟의 GC는 age 별로 오브젝트들을 카테고리화 하는 전략을 사용합니다. 

이를 사용하는 근거는 확률적으로 대부분의 객체들이 짧은 생명주기를 가지기 때문입니다.

<br>

> Young Generation

말 그대로 어린 객체의 영역입니다. GC는 해당 영역의 새로운 객체들은 Eden 영역으로, 가비지 수집 사이클에서 살아남은 객체들은 두개의 생존영역으로 보냅니다.

여기서 발생하는 가비지 수집 이벤트는 miner gc event 라고 합니다

miner gc는 eden 영역이 가득 찼을때 발생하며, 살아남은 객체들은 2개의 Survivor 영역 간에 이동을 하게 됩니다. 

영역을 나눈 목적은 이동시 메모리 압축을 진행해서 메모리 단편화를 방지하고, 이동 횟수의 따른 객체의 연령을 추적하기 위함입니다. 이동 횟수가 특정 임계값을 초과하거나 해당 영역이 포화되었을 경우 Old Generation으로 승격됩니다
<br>

> Old Generation

오래동안 생존한 Young Generation 객체들은 해당 영역으로 이동하게 되고 major gc event 가 발생할 경우 수집됩니다.

<br>

> Permanent Generation

클래스, 메소드와 같은 메타데이터들을 보관합니다. JVM gc는 더 이상 사용되지 않는 영구 세대를 수집하게 됩니다.

고정된 메모리 영역이라는 한계를 극복하기 위해 Java 8부터는 시스템 메모리 영역을 사용하는 Metaspace 영역이 이를 대체했습니 

## Different Types of Garbage Collector
- Serial: 모든 가비지 컬렉션 이벤트는 단일 스레드로 실행되고 이후에 압축을 수행합니다.
- Parallel: miner gc 에는 다중 스레드를 사용하고, major gc 에는 단일 스레드를 사용합니다. 또는 Parallel Old variant 에서는 멀티 스레드를 사용합니다.
- CMS: 모두 멀티 스레드를 사용하여 gc를 진행하며, 애플리케이션 프로세스와 동시에 실행되어 가비지 수집시 발생하는 애플리케이션 중지를 최소화합니다. 메모리 압축을 진행하지 않습니다.
- G1: CMS 대체를 목표로 설계되었습니다. 내부적으로 힙 메모리를 고정된 영역으로 나누고 독립적으로 가비지 컬렉션을 진행합니다. 세대 객체를 옮기는 과정이나 필요에 따라 메모리 압축을 진행합니다.

## Stop the world
STW 이벤트는 가비지 수집시에 애플리케이션 내의 모든 스레드를 일시 중단시키는 것을 말합니다.

메모리의 안정성과 동시성 문제를 회피하는 것을 목적으로 설계되었습니다.

G1 gc의 경우 힙 영역의 분할과 대상 영역 선택으로 STW 이벤트를 최소화합니다.

## Benefits of Java Garbage Collection

C, C++과 달리 도달하지 않는 객체들의 메모리 관리를 자동으로 해준다는 것이 큰 장점입니다.

반면에 퍼포먼스, 세부적인 컨트롤 측면에서 명시적인 메모리 관리의 중요성을 주장하는 의견도 존재합니다.

결과적으로 gc 는 현재 많은 프로그래밍 언어의 표준 구성요소가 되었으며 성능에 부정적인 영향을 끼치는 시나리오에 대해 자바는 gc 를 효율적으로 튜닝할 수 있는 다양한 옵션들을 제공하며 이를 보완하고 있습니다.

## What Triggers Garbage Collection?

gc는 메모리를 되찾아야 하는 다양한 이벤트 시그널들에 의해 트리거가 이루어집니다.

- Allocation Failure: 메모리가 부족해 힙 메모리 할당에 실패할경우
- Heap Size: 힙 사이즈가 특정 임계점을 초과했을 경우 
- System.gc(): 해당 명령어를 통해 gc를 트리거하지만 gc가 발생할 것을 보장하지는 않습니다. 즉 JVM 에게 gc를 제안합니다.
- Time-Based: G1 와 같은 알고리즘들은 시간 기반 트리거를 사용해서 가비지 수집을 진행합니다.

## Ways for requesting JVM to run Garbage Collector
- System.gc(), Runtime.getRuntime().gc(): gc를 요청하지만 보장하지는 않습니다.
- JConsole or VisualVM: JDK 에 존재하는 툴로 자바 애플리케이션의 그래픽 인터페이스를 제공합니다. 버튼을 클릭해서 gc를 진행할 수 있습니다.
- Command-Line Options: -Xmx 옵션으로 힙 사이즈의 최댓값을 설정하거나, -XX:+DisableExplicitGC 옵션으로 System.gc() 를 비활성화 할 수 있습니다.
- Heap Dumps: Java 힙의 스냅샷을 찍는 것을 말합니다. 메모리 누수와 같은 문제를 식별, 분석할 수 있습니다. 

## Why Does a Programmer need to Understand Garbage Collection?

간단한 프로그램의 경우 gc가 크게 문제가 되지 않을 것입니다. 하지만 자바 스킬을 향상시키기 위해 gc의 동작과 튜닝을 이해하는 것은 필수적입니다.

가장 중요한 것은 gc는 언제 발생할지 예측할 수 없고 런타임에 System.gc() 명령어를 날려도 언제 gc가 이루어질지 보장할 수 없습니다.

gc를 튜닝하기 위해서는 먼저 알고리즘을 잘 선정해야 합니다. 주식 거래, 게임 서버와 같이 동시성이 중요시된다면 'Stop the world' 를 방지하는 G1 gc가 효율적일 것입니다.

유저와의 상호작용이 중요하지 않고, 빠르게 돌아가는 것이 중요한 상황이라면 G1 gc 보다 컨텍스트 스위칭이 덜 발생하는 Parallel gc가 효율적일 것입니다.

다음으로는 힙의 최대 사이즈를 설정하는 것과 같이  JVM 플래그를 통해 gc를 튜닝하는 것으로 환경에 맞는 gc를 설정할 수 있습니다.
